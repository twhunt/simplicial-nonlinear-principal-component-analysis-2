function [cand_tri_ovrlap, exstng_tri_ovrlap, cand_tri_cnflcts] ...
    = cand_tri_cnflct2(...
    cand_tri_vrtx_crdnts, ...
    cand_tri_vrtx_is_shrd, ...
    exstng_tri_vrtx_inds, ...
    exstng_tri_shrd_vrtx_inds, ...
    exstng_tri_num_shrd_vrtxs, ...
    vrtx_crdnts, ...
    cnflct_0_shrd_min_dstnc, ...
    cnflct_0_shrd_ovrlap_min_dstnc)

num_exstng_tris = size(exstng_tri_vrtx_inds, 1);

if num_exstng_tris == 0
    cand_tri_ovrlap = {};
    exstng_tri_ovrlap = {};
    cand_tri_cnflcts = false(0);
    
    return
end

num_cand_tri_overlap   = zeros(3, 1);
num_exstng_tri_overlap = zeros(3, 1);

cand_tri_overlaps = false;
cand_tri_cnflcts  = false(1, num_exstng_tris);

num_12_shrd_cnflcts = 0;
num_0_shrd_cnflcts  = 0;

for num_shrd_vrtcs=2:-1:0
    
    tri_list_inds_to_test = ...
        find(exstng_tri_num_shrd_vrtxs == num_shrd_vrtcs);
    
    if ~isempty(tri_list_inds_to_test)
        
        %functions that test for overlap have different calling conventions
        switch num_shrd_vrtcs
            case 2
                
                [cand_tri_ovrlap{3}, exstng_tri_ovrlap{3}] ...
                    = cand_tri_overlap_2_shrd_vrtcs(...
                    cand_tri_vrtx_crdnts, ...
                    cand_tri_vrtx_is_shrd(tri_list_inds_to_test, :), ...
                    vrtx_crdnts, ...
                    exstng_tri_vrtx_inds(tri_list_inds_to_test, :), ...
                    exstng_tri_shrd_vrtx_inds(tri_list_inds_to_test, :));
                
            case 1    
                
                [cand_tri_ovrlap{2}, exstng_tri_ovrlap{2}] ...
                    = cand_tri_overlap_1_shrd_vrtcs(...
                    cand_tri_vrtx_crdnts, ...
                    cand_tri_vrtx_is_shrd(tri_list_inds_to_test, :), ...
                    vrtx_crdnts, ...
                    exstng_tri_vrtx_inds(tri_list_inds_to_test, :), ...
                    exstng_tri_shrd_vrtx_inds(tri_list_inds_to_test, :));
                
            case 0
                
                [cand_tri_ovrlap{1}, exstng_tri_ovrlap{1}] ...
                    = cand_tri_overlap_0_shrd_vrtcs(...
                    cand_tri_vrtx_crdnts, ...
                    vrtx_crdnts, ...
                    exstng_tri_vrtx_inds(tri_list_inds_to_test, :));
                
                min_dstnc_0_shrd_vrtcs(1:numel(tri_list_inds_to_test)) ...
                    = NaN;
                
        end
        
        num_cand_tri_overlap(num_shrd_vrtcs+1) = ...
            sum(cand_tri_ovrlap{num_shrd_vrtcs+1});
        
        num_exstng_tri_overlap(num_shrd_vrtcs+1) = ...
            sum(exstng_tri_ovrlap{num_shrd_vrtcs+1});
        
        cand_tri_overlaps = cand_tri_overlaps ...
           || num_cand_tri_overlap(num_shrd_vrtcs+1) ...
           + num_exstng_tri_overlap(num_shrd_vrtcs+1) > 0;
       
       if cand_tri_overlaps

           tri_list_inds = ...
               tri_list_inds_to_test(...
               cand_tri_ovrlap{num_shrd_vrtcs+1} ...
               | exstng_tri_ovrlap{num_shrd_vrtcs+1});
          
           if num_shrd_vrtcs == 0
               
               loopCount = 0;
               %calculate distance between candidate and existing triangle
               for tri_list_i=tri_list_inds(:)'
                   
                   loopCount = loopCount + 1;
                   
                   [nrst_crds1, nrst_crds2, ...
                       min_dstnc_0_shrd_vrtcs(loopCount), exit_flag] ...
                       = tri_tri_nrst_pts2(...
                       cand_tri_vrtx_crdnts(:, 1), ...
                       cand_tri_vrtx_crdnts(:, 2), ...
                       cand_tri_vrtx_crdnts(:, 3), ...
                       vrtx_crdnts(:, ...
                       exstng_tri_vrtx_inds(tri_list_i, 1)), ...
                       vrtx_crdnts(:, ...
                       exstng_tri_vrtx_inds(tri_list_i, 2)), ...
                       vrtx_crdnts(:, ...
                       exstng_tri_vrtx_inds(tri_list_i, 3)));
                   
                   if exit_flag < 0
                       
                       min_dstnc_0_shrd_vrtcs(loopCount) = NaN;
                       
                       warning(...
                           ['Could not find minimum distance between ' ...
                           'candidate and existing triangle. '...
                           'Probable bug']);
                       
                   else
                       
                       cand_tri_cnflcts(tri_list_i) ...
                           = min_dstnc_0_shrd_vrtcs(loopCount) ...
                           <= cnflct_0_shrd_ovrlap_min_dstnc;
                       
                       
                       if cand_tri_cnflcts(tri_list_i)
                           
                           num_0_shrd_cnflcts = num_0_shrd_cnflcts + 1;
                           
                       end
                   end
                   
                   
               end
           else
               %num_shrd_vrtcs is 1 or 2
               %overlap implies conflict when the candidate triangle shares
               %a vertex with an existing triangle
                   
               num_12_shrd_cnflcts = ...
                   num_12_shrd_cnflcts + numel(tri_list_inds);
               
               cand_tri_cnflcts(tri_list_inds) = true;
           end
           
       end
        
        
    end
    
    
end

%tri_list_inds_to_test = ...
%    find(exstng_tri_num_shrd_vrtxs == 0);

loopCount = 0;
for tri_list_i=tri_list_inds_to_test(:)'
 
    loopCount = loopCount + 1;
    
    if isnan(min_dstnc_0_shrd_vrtcs(loopCount))
        
        [nrst_crds1, nrst_crds2, ...
            min_dstnc_0_shrd_vrtcs(loopCount), exit_flag] ...
            = tri_tri_nrst_pts2(...
            cand_tri_vrtx_crdnts(:, 1), ...
            cand_tri_vrtx_crdnts(:, 2), ...
            cand_tri_vrtx_crdnts(:, 3), ...
            vrtx_crdnts(:, ...
            exstng_tri_vrtx_inds(tri_list_i, 1)), ...
            vrtx_crdnts(:, ...
            exstng_tri_vrtx_inds(tri_list_i, 2)), ...
            vrtx_crdnts(:, ...
            exstng_tri_vrtx_inds(tri_list_i, 3)));
        
    end
    
    if exit_flag < 0
        
        warning(...
            ['Could not find minimum distance between ' ...
            'candidate and existing triangle. '...
            'Probable bug']);
        
        cand_tri_cnflcts(tri_list_i) = true;
        
    else
        
        cand_tri_cnflcts(tri_list_i) ...
            = min_dstnc_0_shrd_vrtcs(loopCount) ...
            <= cnflct_0_shrd_min_dstnc;
        
        
        if cand_tri_cnflcts(tri_list_i)
            
            num_0_shrd_cnflcts = num_0_shrd_cnflcts + 1;
            
        end
    end
    
    
end
